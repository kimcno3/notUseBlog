---
layout: post
title: "객체 지향 4대 특성"
author: kimcno3
categories: java
tags: java
---

> 해당 글은 **김종민**님의 **스프링 입문을 위한 자바 객체 지향의 원리와 이해**의 내용을 정리한 글입니다.

### 1. 추상화 → 모델링 →  `class`
추상화는 **현실의 존재하는 사물이나 객체들의 공통적인 특성을 추출해 묶는 것**을 의미합니다. 그리고 자바에서 추상화는 클래스를 통해 이뤄집니다. 즉, 클래스라는 것은 **객체들의 공통적인 특성을 어플리케이션의 목적에 맞게 묶어 구분한 것을 의미**한다고 볼 수 있습니다.

이처럼 클래스를 정의하는 과정을 추상화, 다른 말로 모델링이라고 할 수 있습니다.

그리고 이러한 클래스들의 특성을 그대로 가지고 동작을 하는 존재를 객체라고 합니다. 그래서 자바를 기반으로 설계된 어플리케이션은 객체들 간의 주고 받는 메세지를 통해 필요한 동작을 수행하며 작동한다고 보면 됩니다.

추상화를 하는 과정에서 공통된 특성을 가지고 정의되는 클래스가 대다수지만, 특정 클래스 타입으로 생성되는 모든 객체가 동일한 변수값을 가지거나, 굳이 객체를 생성하지 않고 활용되어야 하는 경우가 존재합니다. 이런 경우에는 정적 클래스로 모델링을 하는 것이 합리적입니다.

예시) `상수(Enum 클래스)`, `java.util 클래스`

<br>

### 2. 상속 → 재사용성, 확장 → `extends`, `interface`
자바에서 생성되는 클래스들은 상속관계를 맺을 수 있습니다. 상속을 통해서 여러 클래스들의 공통적인 부분을 하나의 클래스로 묶어 정의하게 되면 코드의 중복을 많이 피할 수 있고, 확장의 의미를 가진 클래스들의 관계성을 부여할 수 있습니다.

왜냐하면 상속을 받는 클래스는 상속을 하는 클래스에서 정의된 공통적인 부분도 사용할 수 있으면서 해당 클래스만의 특성도 가질 수 있기 때문입니다. 

이러한 관계성으로 인해 많은 개발서적에서 잘못된 표현법으로 상속에 대해 설명하는데 상속은 `부모-자식`의 관계라기 보단 `상위-하위`의 관계라고 이해하는 것이 더 적합합니다.

그 이유는 상위 클래스는 하위 클래스가 되어야 하며 하위 클래스는 상위 클래스의 종류 중 하나 또는 상위 클래스로써의 역할이 가능해야 하기 때문입니다.

자바에서 상속은 `extends` 나 `impliments`를 통해 구현할 수 있는데 둘 사이에는 약간의 의미 차이가 있습니다.

- 하위 클래스 `extends` 상위 클래스 :  하위 클래스 `is kind of` 상위 클래스
- 하위 클래스 `implements` 상위 클래스 :  하위 클래스 `is able to` 상위 클래스

이러한 의미차이는 아래와 같은 구현 상의 차이점을 발생시킵니다.

- 상속의 경우, 상위 클래스에는 최대한 많은 부분이 정의되어 있어야 합니다.
- 반대로 구현의 경우, 인터페이스에는 최대한 적은 부분이 정의되어 있어야 합니다.

즉, 상속의 경우에는 상위 클래스와 하위 클래스가 같은 방향성을 가지고 공통적인 특성을 상위 클래스로 묶는 것이기 때문에 최대한 많은 부분을 상위 클래스에 선언해야 재사용성을 높힐 수 있습니다.

하지만 구현의 경우 인터페이스에 너무 많은 부분을 선언해버리면 인터페이스를 구현한 클래스가 인터페이스에 의존하는 경향이 강해지고 인터페이스에 너무 많은 책임을 주어지게 하는 문제가 생겨날 수 있기 때문입니다.

인터페이스는 객체를 생성해 동작시키기 위함보다는 특정 역할에 대한 의미를 명시하기 위함이기 때문에 역할을 나눌 수 있다면 최대한 작은 단위로 쪼갤수록 유지보수 측면에서 유리한 설계를 할 수 있습니다. 그렇기 때문에 인터페이스의 선언된 부분이 많은 것을 지양해야 합니다.

<br>

### 3. 다형성 → 사용 편의성 → `overriding`, `overloading`
[위키백과](https://ko.wikipedia.org/wiki/%EB%8B%A4%ED%98%95%EC%84%B1_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)) 에서 정의한 프로그램 언어의 다형성(多形性, polymorphism; 폴리모피즘)은 그 프로그래밍 언어의 자료형 체계의 성질을 나타내는 것으로, 프로그램 언어의 각 요소들(상수, 변수, 식, 오브젝트, 함수, 메소드 등)이 다양한 자료형(type)에 속하는 것이 허가되는 성질을 의미한다.


자바에서 다형성은 상속이나 인터페이스에서도 적용되는 개념이지만 기본적으로 오버라아딩과 오버로딩을 통해 구현된다고 볼 수 있다.

- `overriding` : 같은 이름의 메소드, 같은 인자 → `재정의`
- `overloading` : 같은 이름의 메소드, 다른 인자 → `중복정의`

`오버라이딩`을 통해 상속 관계의 상위 클래스와 하위 클래스가 같은 이름의 메소드를 사용할 수 있지만 리턴값은 다르게 할 수 있고, 인터페이스를 구현하는 경우라면 구현 클래스에 따라 하나의 인터페이스에 선언된 메소드를 다른 방식으로 구현할 수 있습니다. 

또한 `오버로딩`을 통해 같은 이름의 메소드여도 다른 매개변수를 설정함으로써 동적으로 메소드를 활용할 수 있게 해줍니다.
> 오버로딩은 자바에서 추구하는 다형성과는 다른 맥락으로 볼 수 있지만, 하나의 요소를 다양한 모습으로 선언할 수 있다는 점에서 다형성의 일부로 생각합니다.

다형성을 통해 상위 클래스 타입의 객체가 가지는 메소드를 하위 클래스들이 다르게 선언하고 목적에 따라 유연하게 활용할 수 있기 때문에 OOP는 교체에 유연한 설계가 가능하다.

#### 자바에서 다형성을 활용할 때 주의할 점
상위 클래스 타입으로 선언된 참조변수, 하지만 생성자는 하위 클래스일 경우에는 **확장된 메서드는 사용할 수 없지만 재정의된 메서드는 하위 클래스의 메서드가 호출**된다.

```
동물 강아지1 = new 강아지(); -> 동물 타입으로 생성된 객체, 하지만 생성자는 강아지

강아지1.걷다() → 동물 타입이지만 강아지가 걷는 방식으로 호출

강아지1.날다() → 동물 타입이지만 강아지에는 날다라는 메서드가 정의되어 있지 않다. 즉, 확장된 메서드는 호출 불가
```

<br>

### 4. 캡슐화 → 정보 은닉 → `public`, `default`, `protected`, `private`
자바는 클래스 단위로 추상화를 하고 그 안에 변수나 메소드를 선언하는 방식으로 구현된다. 클래스 안에 선언된 내용을 외부로 공개할지, 비공개로 선언할지, 또는 특정 조건에 맞는 클래스에게만 접근을 허용할 지 정할 수 있다. 이를 4가지 접근 제어자를 통해 지정할 수 있다.

즉, 개발자의 목적에 따라 정보를 숨길 수 있다.